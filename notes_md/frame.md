# 回顾

上节课我们讨论了深度学习的优化算法，包括SGD动量，也可以对SGD动量进行一点微调。也讨论了正则化，尤其要记住的是 dropout，它在正向传播过程中将网络的某些部分随机的设置为0，然后在测试时消除这些随机性。我们发现在不同的正则化中，这是普遍的模式：在深度学习的训练中加入一些噪声，在测试时再将噪声边缘化。我们还讨论了迁移学习，可以先下载一些相似的大的数据集预训练网络模型，然后根据自己的实际任务进行微调。这个方法可以帮助你在没有很大数据集的情况下也能完成深度学习任务。

# 前言

今天要讲一些关于编写软件和硬件，以及它们如何工作的细节。以及了解一下软件的实际应用流程，讨论一些主流的 CPU 和GPU。然后讨论几个主流的深度学习框架。

# CPU vs GPU

我们已经知道，计算机有CPU和GPU，深度学习使用GPU。但是并没有指出它们具体是什么，以及为什么在深度学习中GPU的表现要更好。

## CPU的介绍

CPU的全程是 Center Processing Unit ,中央处理器。就是下图这个小芯片。

<img src="https://raw.githubusercontent.com/verfallen/cs231n-2017-notes/main/img/image-20220416230736091.png" alt="image-20220416230736091" style="zoom:50%;" />

## GPU的介绍

CPU 的全程是 Graphic Processing Unit，图形处理器。相对于CPU来说，GPU的体积大得多，它有自己的冷却系统，并且耗电更多。

从GPU的名字就可以看出来，他最初是被用于渲染计算机图形，是围绕游戏而开发的。

<img src="https://raw.githubusercontent.com/verfallen/cs231n-2017-notes/main/img/image-20220416231035325.png" alt="image-20220416231035325" style="zoom: 50%;" />

我们知道的GPU一般有NVIDIA 和 AMD。深度学习中，我们基本上选择NVIDIA。使用AMD的显卡来做深度学习可能会遇到各种麻烦。

事实上，NVIDIA 一直大力推动深度学习。他们投入了很多人力物力来让他们的显卡更适合深度学习。所以，谈起深度学习中的GPU通常实质NVIDIA的GPU。

## CPU和GPU对比

CPU和GPU都是一种通用的计算机器。但是在性质上极为不同。

CPU的核数很少，可以利用多线程技术。也就是说，他们在硬件上可以同时运行多个线程。线程可以实现很多操作，并且运行速度非常快，运作相互独立。

+ GPU有上千上万的核数。GPU的每一个核都运行缓慢，能执行的操作没有CPU多。
+ GPU的核不能独立运行，它们需要共同协作。因为GPU有大量的核，当你需要同时执行操作时，它的并行能力很强。

CPU 跟 GPU 还有一点需要指明的是内存的概念。

+ CPU 有高速缓存但是相对比较小，而且CPU 的大部分内存都是依赖于系统内存。在一台典型的消费级台式机上- RAM -的容量可能有8，16或者32GB。
+ GPU 中内置了 RAM。 GPU 与系统RAM通信时，会带来产重的性能瓶颈，因此GPU 基本上拥有自己相对较大的内存。Titan XP 它的本地内存有12个GB。GPU 也有它自己的缓存系统，所以在 GPU的12个 G和GPU 核之间有多级缓存。它跟 CPU 的多层缓存类似。

![image-20220416232211582](https://raw.githubusercontent.com/verfallen/cs231n-2017-notes/main/img/image-20220416232211582.png)

## GPU 的并行能力

CPU 对于通信处理来说是友好的。而 GPU 更擅长于处理高度并行的算法其中最典型的的就是就是处理矩阵乘法。

下图中，左图是一个 A*B 的矩阵，乘以一个 B * C 的矩阵，最后得到一个规模为 A*C的输出矩阵。对于输出矩阵来说，每一个元素都是第一个矩阵的某一行与第二个矩阵的某一列的点积的结果。这些点积运算都是相对独立的。想象一下，将输出矩阵中每个元素并行计算，并且所有的计算都是两个向量点积的运算。实际上就是从两个输入矩阵的不同位置进行读取数据，然后进行点积，填到对应位置上。这是一个典型的适用于CPU解决的问题。

如果使用CPU来进行矩阵乘法的运算，可能会进行串行计算，就是对每个元素一个个进行计算。现在，CPU拥有多核，也可是进行矢量运算，但是针对并行任务，CPU通常表现得更好。特别是当矩阵规模非常庞大的时候。

<img src="https://raw.githubusercontent.com/verfallen/cs231n-2017-notes/main/img/image-20220418000318804.png" alt="image-20220418000318804"  />

## GPU 计算架构

可以在 GPU 上写出可以直接运行的程序。NVIDIA 有个叫做 CUDA 的抽象代码，可以让你写出类 C的代码，并且可以在 GPU上直接执行。但是想要写出高性能
并且充分发挥 GPU 性能的 CUDA 代码，是很困难的。你必须非常谨慎地管理内存结构，并且不遗漏任何一个高速缓存，以及分支误预测等等。所以自己编写高性能的 CUDA 代码是非常困难的。

NVIDIA 开源了很多的库，这些库实现了通用的计算语言，可以用来实现高度优化。举个例子，NVIDIA 有个叫做 **cuBLAS** 的库，可以**实现各种各样的矩阵乘法**，并且矩阵操作都是被高度优化的，可以在 GPU 上很好地运行，非常接近硬件利用率的理论峰值。还有一个叫做**cuDNN** 的库可以**实现卷积，前向和反向传播，批量归一化，循环神经网络等**。还有另一种语叫做**openCL**，这种语言在深度学习中更加普及**。它不仅可以在 NVIDIA GPU 上运行，还可以在 AMD 以及 CPU 上运行。**但是没有人花费大量的精力优化 openCL，所以 openCL 在性能上并没有 CUDA 好。

## CPU和GPU性能表现

将Intel 的 CPU8-14 和当时性能最好的GPU Pascal Titan X做一下性能比较，下图是测试的结果。更详细的结果可以 [参考这里。](https://github.com/jcjohnson/cnn-benchmarks)对于VGG 16/19 和不同层数的ResNet ，**对于同样的计算任务，CPU耗时是 GPU的65到75倍。**这个测试对CPU有些不公平，因为没有压榨出CPU的最大性能。只是在CPU直接安装运行了torch。



![image-20220418004740182](https://raw.githubusercontent.com/verfallen/cs231n-2017-notes/main/img/image-20220418004740182.png)

另一个有趣的结果是,比较了卷积优化的 cuDNN 库和没有经过优化的 直接以 CUDA 写成的代码，在相同的网络相同的硬件相同的 Deep Learning 框架上，可以在图表中看到大约有3 倍的速度差距。也就是说优化过的 cuDNN比原生 CUDA版代码快这么多。所以一般来说只要你在 GPU 上写代码,你就应该使用 cuDNN.

![image-20220418163640703](https://raw.githubusercontent.com/verfallen/cs231n-2017-notes/main/img/image-20220418163640703.png)

## CPU和GPU的通信

在训练网络的时候，你的模型可能存储在 GPU 上，但是庞大的数据集却存储在机械硬盘或者是固态硬盘上。从硬盘中读取数据的很可能成为训练速度的瓶颈。因为 GPU 非常快，它计算正向反向传播的速度非常快，从硬盘上串行地读取数据会拖慢训练速度，这会让训练变慢。

有一些解决的方法：如果数据集比较小，你可以把整个数据集读到内存中。或者数据集不小但是你有台内存足够大的服务器，也可以这么干。或者装固态硬盘替换掉机械硬盘，提升读取数据速度。

另一种常用的思路是：**在 CPU 上使用多线程来预读数据**。把数据读出内存或者读出硬盘存储到内存上，这样就能连续不断地将缓存数据高效地送给 GPU。这种方法不太容易实现，因为 GPU 太快了，如果不能及时把数据发送给 GPU，仅仅读取数据这一项就会拖慢整个训练过程。

## 关于CPU和GPU的提问

**<u>Q：在编写代码时，如何有效避免上述提到的问题？</u>**

A：从软件层面来说，最有效的事情就是 **设定CPU预读数据**。比如用多个 CPU 线程从硬盘中读取数据。GPU 在运算的同时，CPU 的后台线程从硬盘中取数据，主线程等待这些工作完成，在它们之间做一些同步化，让整个流程并行起来。如果你使用了下面要讲到的这些深度学习框架，它们已经替你完成了这部分操作。

# 深度学习框架

去年讲这门课的时候，主要讲的是caffe，torch，Theano 和 TensorFlow。Tensorflow那时候刚发布，还没有得到很广泛的使用。但在过去一年里，Tensorflow已经变得非常流行了，它可能是大多数人使用的主要框架，这是很大的变化。各种各样的新框架如雨后春笋般发布出来。尤其是 Caffe2 和 Pytorch 这两个来自Facebook 的新框架，百度有 Paddle ，微软有 CNTK，亚马逊用MXNet，还有很多其他的框架。

从图上可以发现很有趣的一点是，第一代深度学习框架大多是由学术界完成的。Caffe 来自伯克利，torch 起初由纽约大学维护，后来是与 Facebook 合作维护。Theano 主要由蒙特利尔大学实现。但是下一代深度学习框架全部由工业界产生。Facebook 做了 Caffe2 和 PyTorch，Google 做了 Tensorflow。过去几年里，一个有趣的转变发生了。这些想法从学术界转移到了产业，产业界提出了强大的框架来进行工作。

![image-20220418203043362](https://raw.githubusercontent.com/verfallen/cs231n-2017-notes/main/img/image-20220418203043362.png)

## 计算图

无论何时你进行深度学习，都要考虑构建计算图来计算目标函数。在线性分类器中，数据 X和权重 W进行矩阵乘法，可能使用 hinge loss 损失函数来计算损失，可能会再加一些正则项，将这些不同的操作拼起来成为一些图结构，叫做**计算图**。

![image-20220418203535149](https://raw.githubusercontent.com/verfallen/cs231n-2017-notes/main/img/image-20220418203535149.png)

在大型神经网络中，计算图结构非常复杂。有很多不同的层，不同的激活函数，不同的权重，在这个非常复杂的图中。而且你使用像神经图灵机这样的东西，
得到这些非常疯狂的计算图。因为它们实在是太庞杂了，你甚至不能将其画出来。所以深度学习框架意义重大。

<img src="https://raw.githubusercontent.com/verfallen/cs231n-2017-notes/main/img/image-20220418203637611.png" alt="image-20220418203637611"  />

## 深度学习框架的优点

有三点：

+ 可以轻易构建大型计算图
+ 容易计算梯度
+ 可以在GPU上高效运行

针对第一点，我们前面已经说过，在大型神经网络中，计算图结构非常复杂，构建这样的结构耗时耗力。我们希望框架能够自动做好这一步。

针对第二点，使用深度学习总需要计算损失在权重方向上的梯度，我们希望框架能够自动计算梯度，而不是自己去编写计算梯度的代码、

针对第三点，我们已经知道GPU有强大的并行计算能力，所以我们希望代码能在GPU上高效运行。不需要额外关注硬件细节。

## 计算图实现的不同方式

举个例子，这里有三个输入 X，Y，Z，我们要结合x和 Y来生成 A，然后再结合 a和 z来生成 b，最后我们要对 b 进行求和操作，将值传给最终的结果 C。

![image-20220418210829591](https://raw.githubusercontent.com/verfallen/cs231n-2017-notes/main/img/image-20220418210829591.png)


下图是使用NumPy实现这个计算图的代码，但是NumPy 只能在CPU端运行，无法利用GPU来进行加速。而且，使用NumPy，必须要自己计算梯度。这很麻烦，所以大部分深度学习框架的目标是 **编写像前向传播的代码，但是能够在GPU上运行，并且自动计算梯度**。

![image-20220418210937579](https://raw.githubusercontent.com/verfallen/cs231n-2017-notes/main/img/image-20220418210937579.png)

这是一个在 TensorFlow 中实现相同计算图的例子。其中前向传播的代码与NumPy 相似。但是 TensorFlow 中，只写了一行代码用来计算梯度（见下图），十分方便。

![image-20220418213040259](https://raw.githubusercontent.com/verfallen/cs231n-2017-notes/main/img/image-20220418213040259.png)

TensorFlow的运行可以CPU和GPU上进行切换。如下图所示，使用 `tf.device()`来实现。左图是在CPU上运行，右图是在GPU上运行。

<img src="https://raw.githubusercontent.com/verfallen/cs231n-2017-notes/main/img/image-20220418213245756.png" alt="image-20220418213245756" style="zoom: 67%;" /><img src="https://raw.githubusercontent.com/verfallen/cs231n-2017-notes/main/img/image-20220418213234659.png" alt="image-20220418213234659" style="zoom: 67%;" />

用 PyTorch 实现相同的计算图，代码看起来也差不多。首先定义变量开始构建一个计算图（红色框圈住的部分），然后进行前向传播（黄色框圈住的部分），之后计算梯度（蓝色框圈住的部分）。

![image-20220418214050739](https://raw.githubusercontent.com/verfallen/cs231n-2017-notes/main/img/image-20220418214050739.png)

在 PyTorch 中切换到 GPU 非常容易，只需要在运行计算之前把数据都转换成 CUDA 数据类型即可。

![image-20220418214504011](https://raw.githubusercontent.com/verfallen/cs231n-2017-notes/main/img/image-20220418214504011.png)

通过观察完整的代码可以知道，TensorFlow 和 PyTorch 的代码在前向传播中与Numpy 看起来几乎完全一样。这是因为Numpy 有一个很好的接口，它非常容易用来一起工作。

## 一个两层ReLU 网络的TensorFlow 实例

以下的内容，我们使用一个两层的全连接ReLU 网络作为示例来讲解。输入随机数据，损失使用L2欧氏距离。这个示例并没有做什么有用的事情，仅仅为了讲解用。

从下图可以看出，代码可以分为两个阶段。

1. 定义计算图，这个计算图会运行多次
2. 将数据输入到计算图中

这个TensorFlow 非常通用的一种模式，**首先构建计算图，然后重复利用运行图模型**。

![image-20220419115258468](https://raw.githubusercontent.com/verfallen/cs231n-2017-notes/main/img/image-20220419115258468.png)

下图是详细分析构建计算图的部分（红色框的部分）。

**黄色框部分的是构建`placeholder`对象，**我们定义了 X和 Y，W1和w2并且创建了这些变量的`tf.placeholder` 对象。这些变量会成为图的输入结点，这些结点又是图中的入口结点。当我运行图模型时会输入数据，就是将它们放到我们计算图中的输入槽中，这跟内存分配没有一点相似之处，我们只是为计算图建立了输入槽，然后我们用这些输入槽在对应的符号变量上执行各种 TensorFlow 操作以便构建。

**蓝色框部分是进行前向传播，计算y的预测值和L2距离损失。**我们做了一个矩阵乘法，然后使用`tf.maximum` 来实现 ReLU 的非线性特性。接着另用矩阵乘法来计算y的预测值。然后使用用基本的张量运算来计算欧氏距离，计算目标值 y 和预测值之间的 L2损失。需要注意的是，这里的代码没有做任何实质上的运算，只是建立计算图结构来告诉 Tensor Flow当输入真实数据时怎样执行。

**绿色框部分是计算梯度，**在这个示例中就是让 Tensor Flow 去计算损失值在w1和w2方向上的梯度。这里同样没有进行实际的计算，它只是在计算图中加入额外的操作，让计算图算出梯度。

![image-20220419115451727](https://raw.githubusercontent.com/verfallen/cs231n-2017-notes/main/img/image-20220419115451727.png)